<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TEST</title>
    <url>/2021/04/28/TEST/</url>
    <content><![CDATA[<p>测试用例</p>
<span id="more"></span>

<p>咕咕咕</p>
<p>$\vec{a_i}=(a_{i,1} \bmod 2,a_{i,2} \bmod 2, \dots ,a_{i,k} \bmod 2) \in(\mathbb{Z}_{2})^k$</p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>tag</tag>
      </tags>
  </entry>
  <entry>
    <title>高效因子分解</title>
    <url>/2021/04/28/%E9%AB%98%E6%95%88%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p>本文主要包括了一些常见和不常见的高效因子分解算法，重点在于椭圆曲线法的讲解（虽然Dixon’s 的篇幅更多一些貌似）</p>
<span id="more"></span>

<p>主要参考为 Wikipedia 的 Integer Factorization 页面</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>质因数分解一直是一个密码学领域相当热门的话题，因为他直接关系着 RSA 等使用大素数相乘来加密的算法的安全性</p>
<p>相比于</p>
<ul>
<li><p>求素数（筛法或者特殊的生成法）</p>
</li>
<li><p>素性测验(能做到$O((\log n))^{6+\epsilon}$)</p>
</li>
<li><p>素数计数（求$[1,n]$的素数个数，可以使用Meissel-Lehmer在亚线性复杂度内求解）</p>
</li>
</ul>
<p>因数分解一直是一个很困难的内容</p>
<p>现有的对于一般数字分解的最好算法是GNFS（General Number Field Sieve，一般数域筛）的复杂度为$L_n[\frac{1}{3},\sqrt[3]{\frac{64}{9}}]=\exp((\sqrt[3]{\frac{64}{9}}+o(1)(\ln n)^\frac{1}{3}(\ln\ln n)^{\frac{2}{3}})$</p>
<p>能够分解上百位的合数</p>
<p>而数域筛涉及到大量的代数数论的内容，故笔者在此介绍一些更加简单易懂的算法包括 ：</p>
<p>Dixon’s ，CFRAC 和 Lanstra 椭圆曲线 算法</p>
<p>大概只需要一些基本的数论知识（和一小点群论），同时给出了一个椭圆曲线法的Python Demo</p>
<h2 id="基础的想法"><a href="#基础的想法" class="headerlink" title="基础的想法"></a>基础的想法</h2><h3 id="试除"><a href="#试除" class="headerlink" title="试除"></a>试除</h3><p>一个基础的想法是在$[2,\sqrt n]$的范围内试除，复杂度为$O(\sqrt n)$，虽然在 OI 里很多情况下都已经够用，但是对于分解数十甚至上百位整数的需求就难以接受</p>
<h3 id="Fermat"><a href="#Fermat" class="headerlink" title="Fermat"></a>Fermat</h3><p>而 Fermat 分解提供了一个新的思路</p>
<p>注意到若奇合数 $n=pq$ 那一定可以表示为两数平方差 $a^2-b^2$ 仅需取 $a=\frac{p+q}{2} \quad b=\frac{p-q}{2}$</p>
<p>变形一下得到 $a^2-n=b^2$ 那我们枚举 $a$ 测试 $a^2-n$ 是否为完全平方数即可</p>
<p>但是这样的复杂度为 $O(n)$ 甚至更慢，但是能够对更快的的质因数分解做出一定的启示</p>
<p>比如我们考虑如果放宽要求 $a^2\equiv b^2 \pmod n$ 那么$\gcd(a - b,n)$ 就很可能是一个非平凡因子</p>
<p>因为有$n|(a-b)(a+b)$，所以$\gcd(a-b,n) ,\gcd(a+b,n)$一定有一个因子 (只要不是 $a=\pm b$)</p>
<h2 id="Pollard’s-Rho算法"><a href="#Pollard’s-Rho算法" class="headerlink" title="Pollard’s Rho算法"></a>Pollard’s Rho算法</h2><p>该算法是 OI 中<strong>不</strong>常用的算法之一，但是是一个极好的高效因数分解的例子</p>
<p>Pollard’s Rho算法的思想是在接近随机的数列${x_i}:x_{i+1}= (x_i^2+c) \bmod n$</p>
<p>出现$x_a\equiv x_b\pmod n$的期望步数为$O(\sqrt n)$ （根据生日悖论）</p>
<p>而对于$n=pq$ 的 ${x_i \bmod p}$ 依然是接近随机行为的数列，同时期望为$O(\sqrt p)$</p>
<p>于是只要$x_a\ne x_b$计算$\gcd(x_a-x_b,n)$就得到了一个$n$的非平凡因子</p>
<p>于是我们得到了$O(\sqrt p)$或者说$O(n^{\frac{1}{4}})$的优秀算法</p>
<h2 id="亚指数级"><a href="#亚指数级" class="headerlink" title="亚指数级"></a>亚指数级</h2><p>$O(n^{\frac{1}{4}})$已经很快的，在 OI 中大概也是极限了（再大建议物理解决出题人）</p>
<p>但是它仍然不！够！快！</p>
<p>下面是 Linux 下 <code>factor</code> 的速度（内部实现为 Pollard’s Rho）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time factor 60000000000000003100000000000000033</span><br><span class="line">60000000000000003100000000000000033: 200000000000000003 300000000000000011</span><br><span class="line">factor 60000000000000003100000000000000033  38.38s user 0.00s system 99% cpu 38.383 total</span><br></pre></td></tr></table></figure>

<p>可以看到分解仅 $35$ 位的合数就用了 $38$ s 这显然是不能接受的 （实际上 Linux 的跑的相当快,我写的丢人 Pollard’s Rho 跑了两分钟还没跑出来</p>
<p>而我们完全可以用 Fermat 的想法做到更快的分解速度</p>
<h3 id="Dixon’s-与-连分数-CFRAC"><a href="#Dixon’s-与-连分数-CFRAC" class="headerlink" title="Dixon’s 与 连分数 (CFRAC)"></a>Dixon’s 与 连分数 (CFRAC)</h3><p>为了方便的叙述先定义两个概念</p>
<h4 id="因子基"><a href="#因子基" class="headerlink" title="因子基"></a>因子基</h4><p>一个因子基意味前几个素数的集合${p_1,p_2,p_3,\dots}$</p>
<h4 id="L记号"><a href="#L记号" class="headerlink" title="L记号"></a>L记号</h4><p>L 记号同样是衡量时间复杂度的，$L_n[a,c]=\exp{(c+o(1)(\ln n)^a(\ln \ln n)^{1-a})}$</p>
<p>其中 $c &gt; 0,a \in [0,1]$</p>
<p>主要用来数论中算法的复杂度</p>
<h4 id="Dixon’s"><a href="#Dixon’s" class="headerlink" title="Dixon’s"></a>Dixon’s</h4><p>Dixon’s 的主要思想是：</p>
<p>选定一个大小为 $b$ 的因子基 $B$，选取一些数字$x_i$，使得 $x_i^2\bmod n=\prod p_i^{k_i}$ 的所有 $p_i \in B$ （显然不会所有的$k_i$都为偶数，否则就找到了一个$a^2\equiv b^2$）</p>
<p>然后通过奥妙重重的方法选取一系列$x_i$使得 $\prod x_i \equiv (\prod p_i^{k_i})^2 \pmod n$</p>
<p>这样我们就得到了一个$a^2 \equiv b^2 \pmod n$</p>
<p>那我们怎么才能寻找到这个奥妙重重的方法呢？</p>
<p>考虑 $\prod x_i \bmod n = \prod p_i^{a_{i,1}+a_{i,2}+a_{i,3}+\dots}$</p>
<p>令 $\vec{a_i}=(a_{i,1} \bmod 2,a_{i,2} \bmod 2, \dots ,a_{i,k} \bmod 2) \in(\mathbb{Z}_{2})^k$</p>
<p>可以用高斯消元解出来向量 $\vec{a}=(0,0,0,\dots,0) \in (\mathbb{Z}_2)^k$</p>
<p>把对应的数字乘起来即可</p>
<p>而 $x_i$ 的选取则是完全随机的（</p>
<p>大概分析下复杂度</p>
<p>对于确定的 $b=n^{-\alpha}$ 而言 找到一个合适的 $x$ 的概率大概是是 $a^{-\alpha}$ （这实际上Dickman function $\rho$ 的一个近似，之后我们会在椭圆曲线那里讨论） </p>
<p>而对于这个 $b$ 我们仅需找到 $\pi(b)$ 个 $x$ 即可总共随机约 $\exp{(\alpha+1)\ln \alpha +\frac{\ln n}{\alpha} -\ln\ln n}$ 次数 每次需要 $\pi(b)$ 次试除</p>
<p>取 $\alpha=2\sqrt{\frac{\ln n}{\ln \ln n}}$ 得到复杂度约为$L_n[\frac{1}{2},2\sqrt2]$</p>
<h3 id="连分数-CFRAC"><a href="#连分数-CFRAC" class="headerlink" title="连分数(CFRAC)"></a>连分数(CFRAC)</h3><p>笔者并没有系统的学习过连分数相关的理论，故仅在此给出简单的介绍</p>
<p>连分数因数分解实际上在 Dixon’s 上的一个优化</p>
<p>我们发现如果 $x^2 \bmod n$ 比较小的话就容易分解</p>
<p>那么用周期连分数表示 $\sqrt {kn}$ 来得到比较好的精度 这样可以做到 $L_n[\frac{1}{2},    \sqrt2]$</p>
<p>(抄的Wikipedia，如果有懂的大佬希望可以给出相关文献QAQ)</p>
<h3 id="二次筛"><a href="#二次筛" class="headerlink" title="二次筛"></a>二次筛</h3><p>二次筛法同样是对 Dixon’s 的优化，可以做到 $L_n[\frac{1}{2},1]$ 在 GNFS 之前一直是最快的因子分解算法</p>
<p>具体原理在学了，学会了也许会单独写一篇</p>
<h2 id="椭圆曲线法"><a href="#椭圆曲线法" class="headerlink" title="椭圆曲线法"></a>椭圆曲线法</h2><p>虽然椭圆曲线法同样是亚指数级别的，但是因为要给出比较详细的讲解故将其分离了出来</p>
<h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><h4 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h4><p><del>椭圆曲线是域上亏格为1的光滑射影曲线</del> </p>
<p>我们可以理解为形如 $y^2=x^3+ax+b$ 的曲线</p>
<h4 id="B-smooth"><a href="#B-smooth" class="headerlink" title="B-smooth"></a>B-smooth</h4><p>当我们说 $n$ 是 B-smooth 的指的是 $n$ 所有的质因子都小于等于 $B$</p>
<h4 id="B-powersmooth"><a href="#B-powersmooth" class="headerlink" title="B-powersmooth"></a>B-powersmooth</h4><p>同样的，B-powersmooth 指的是 $n$ 的任意因子的次幂不超过 $B$ 例如 $2^4 \times 3^2$ 是 16-powersmooth的</p>
<h4 id="椭圆曲线群"><a href="#椭圆曲线群" class="headerlink" title="椭圆曲线群"></a>椭圆曲线群</h4><p>我们在椭圆曲线上的点 $P,Q$ 定义加法为 $P+Q=T$，$T$是椭圆曲线上 $P,Q$ 两点连线的第三个交点的关于 $x$ 轴的对称点（这样定义是为了保持群的结构和交换）</p>
<p>定义自己加自己是沿着自己的切线的交点</p>
<p>再定义无穷远点记作$O$，容易验证椭圆曲线上的点加上点 $O$ 和加法构成结构是一个阿贝尔群，点 $O$ 是其幺元</p>
<h3 id="Pollard’s-p-1"><a href="#Pollard’s-p-1" class="headerlink" title="Pollard’s p-1"></a>Pollard’s p-1</h3><p>虽然 Pollard’s p-1 算法甚至不是正确的（不一定能得到答案）</p>
<p>但是它仍然有着借鉴意义</p>
<p>Pollard’s p-1 算法的思想是如果 $n=pq$</p>
<p>那么  $a^{k(p-1)} \equiv 1 \pmod p$ （费马小定理）</p>
<p>如果 $a$ 的 某个幂次是模 $n$ 的因子同余于 $1$ 那么 $\gcd(a-1,n)$ 大概率是一个 $n$ 的非平凡因子</p>
<p>我们选取一个 B-smooth 的数字 $M$ ，然后计算 $\gcd(x^M,n)$ 重复多次以寻找因子</p>
<p>而 $x$ 需要选取互质于 $n$ 的数字 对于奇合数来说选 $2$ 即可</p>
<h3 id="椭圆曲线法-1"><a href="#椭圆曲线法-1" class="headerlink" title="椭圆曲线法"></a>椭圆曲线法</h3><p>我们将椭圆曲线限制在有理点上，可以发现群的结构仍然保持</p>
<p>我们可以考虑有限域$\mathbb{F}_q$而非有理域，因为我们不需要有理数的结构</p>
<p>考虑椭圆曲线上的加法过程</p>
<p>令 $s=\frac{3x^2+a}{2y}$</p>
<p>则 $2(x,y)=(s^2-2x,y+s(u-x))$</p>
<p>如果我们在 $E(\mathbb{Z}/n\mathbb{Z})$ 下出现了无法除 $2y$ 的情况 ，那么我们在模 $n$ 意义下出现了不存在的逆元，也就是 $\gcd(n,t)\neq1$ 我们就大概率找到了一个因子</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li><p>选定一条曲线 $y^2=x^3+ax+b$ 与非平凡点 $P$</p>
</li>
<li><p>选定素数上界 $B$</p>
</li>
<li><p>计算 $(\prod\limits_{p_i&lt;B}p_i^{\ln B/\ln p_i})P$  （$\ln B/\ln p_i$ 是为了保证这个数 B-powersmooth）</p>
</li>
<li><p>加法过程中寻找因子</p>
</li>
</ol>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>可以发现我们的基本思想是和 Pollard’s p-1 相同，只不过把质数改成了在椭圆曲线群上的加法</p>
<p>所以它为什么比Pollard’s p-1 要好呢？</p>
<p>Pollard’s p-1 的本质在于在群 $\mathbb{Z}_q \times \mathbb{Z}_p$ 中找到了一个 $\mathbb{Z}_p$ 的幺元 $e_p$ 但是非 $\mathbb{Z}_q$ 的幺元</p>
<p>而这个群的阶 $p-1$ 不一定是一个 B-powersmooth 的数</p>
<p>而根据 Hasse 定理，椭圆曲线群 $|E(\mathbb{Z}/p\mathbb{Z})|\in[p+1-2\sqrt p,p+1+2\sqrt p]$</p>
<p>这样群的阶就会有变化，避免了不 powersmooth 的问题</p>
<p>进一步我们考虑曲线 $y^2=x^3+ax+b$ 分别在模 $p$ $q$ 意义下的群 $E(\mathbb{Z}/p\mathbb{Z})$ 与 $E(\mathbb{Z}/q\mathbb{Z})$ （假设 $n=pq$）</p>
<p>记他们的元素数量为 $N_q$ $N_p$ </p>
<p>根据拉格朗日定理（$|G|=[G:H]\times |H|$）若 $kP=O \pmod p$ </p>
<p>那么$N_pP=O \pmod p$</p>
<p>于是和 Pollard’s p-1 一样，如果我们找到了某个 $k$ 使得 $kP=O \pmod p$ 但不是$E(\mathbb{Z}/q\mathbb{Z})$ 中 $P$ 的阶，此时我们就找到一个因子</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>找到一个可分解的椭圆曲线群的概率为 $B\ln^2n$</p>
<p>若设$B=p^{-a}$ 终止的概率为 $a^{-a}$</p>
<p>和 Dixon’s 一样的分析能得到复杂度大致为 $L_p[\frac{1}{2},\sqrt2]$ $p$ 为 $n$ 的最小素因子</p>
<p>可以看到椭圆曲线法的复杂度主要取决于 $n$ 的最小素因子大小而非 $n$ </p>
<p>所以椭圆曲线法可以快速去除一些小的素因子（大约 $30 \sim 40$ 位的素因子）</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>操作中选取曲线上的非平凡点这个行为可以变为随机一个点然后生成一个曲线</p>
<p>对于点 $(x,y)$ 选取一个 $a$ 计算得到 $b=y^3-x^3-ax$</p>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EulerSieve</span>(<span class="params">n</span>):</span></span><br><span class="line">    vis = [<span class="literal">True</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    primes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> vis[i]:</span><br><span class="line">            primes.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> primes:</span><br><span class="line">            <span class="keyword">if</span> i * j &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            vis[i * j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    q, r = <span class="built_in">divmod</span>(a, b)</span><br><span class="line">    x, y, d = exgcd(b, r)</span><br><span class="line">    <span class="keyword">return</span> y, x - q * y, d</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elliptic_add</span>(<span class="params">p, q, a, b, m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p[<span class="number">2</span>] == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">    <span class="keyword">if</span> q[<span class="number">2</span>] == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">if</span> p[<span class="number">0</span>] == q[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">1</span>] + q[<span class="number">1</span>]) % m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        num = (<span class="number">3</span> * p[<span class="number">0</span>] * p[<span class="number">0</span>] + a) % m</span><br><span class="line">        denom = (<span class="number">2</span> * p[<span class="number">1</span>]) % m</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        num = (q[<span class="number">1</span>] - p[<span class="number">1</span>]) % m</span><br><span class="line">        denom = (q[<span class="number">0</span>] - p[<span class="number">0</span>]) % m</span><br><span class="line">    inv, _, g = modular_inv(denom, m)</span><br><span class="line">    <span class="keyword">if</span> g &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, denom  </span><br><span class="line">    z = (num * inv * num * inv - p[<span class="number">0</span>] - q[<span class="number">0</span>]) % m</span><br><span class="line">    <span class="keyword">return</span> z, (num * inv * (p[<span class="number">0</span>] - z) - p[<span class="number">1</span>]) % m, <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elliptic_mul</span>(<span class="params">k, p, a, b, m</span>):</span></span><br><span class="line">    res = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">2</span>] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res = elliptic_add(p, res, a, b, m)</span><br><span class="line">        k = k // <span class="number">2</span></span><br><span class="line">        p = elliptic_add(p, p, a, b, m)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lenstra</span>(<span class="params">n, limit</span>):</span></span><br><span class="line">    g = n</span><br><span class="line">    <span class="keyword">while</span> g == n:</span><br><span class="line">        q = randint(<span class="number">0</span>, n - <span class="number">1</span>), randint(<span class="number">0</span>, n - <span class="number">1</span>), <span class="number">1</span></span><br><span class="line">        a = randint(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        b = (q[<span class="number">1</span>] * q[<span class="number">1</span>] - q[<span class="number">0</span>] * q[<span class="number">0</span>] * q[<span class="number">0</span>] - a * q[<span class="number">0</span>]) % n</span><br><span class="line">        g = gcd(<span class="number">4</span> * a * a * a + <span class="number">27</span> * b * b, n) </span><br><span class="line">    <span class="keyword">if</span> g &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    primes=EulerSieve(limit)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> primes:</span><br><span class="line">        pp = p</span><br><span class="line">        <span class="keyword">while</span> pp &lt; limit:</span><br><span class="line">            q = elliptic_mul(p, q, a, b, n)</span><br><span class="line">            <span class="keyword">if</span> q[<span class="number">2</span>] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> gcd(q[<span class="number">2</span>], n)</span><br><span class="line">            pp = p * pp</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n=<span class="number">998244354</span></span><br><span class="line">    B=<span class="number">7000</span></span><br><span class="line">    curve_count=<span class="number">200</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(curve_count):</span><br><span class="line">        res=lenstra(n, B)</span><br><span class="line">        <span class="keyword">if</span> res != <span class="literal">False</span>:</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h3><h4 id="B的选定"><a href="#B的选定" class="headerlink" title="B的选定"></a>B的选定</h4><p>如果定义 $\Phi(x,y)$ 为 $\le x$ 的 y-smooth 的数的个数，那么 $\Phi(x,x^{-a}) \sim x\rho(a)$</p>
<p>其中 $\rho$ 是之前提到过的 Dickman Function ，定义为 $x\rho’(x)+\rho(x-1)=0$</p>
<p>我们希望最小化 $\Phi(p,B)^{-1}\pi(B)$ 的值</p>
<p>如果采用近似 $\Phi(n,n^{-a}) \sim n\rho(a) \quad \pi(B) \sim \mathrm{Li}(B)$</p>
<p>可以用牛顿迭代一类的方法找极值，当然通常使用经验对 $30$ 位左右的数字用 $7000$ 的 B 即可</p>
<h4 id="多曲线"><a href="#多曲线" class="headerlink" title="多曲线"></a>多曲线</h4><p>我们可以一次性生成多条曲线，一起在这多条曲线上做加法，这样只要有一个曲线上找到了因子就可以退出</p>
<p>求逆元的时候也可以先求一次然后然后用乘法来算其他逆元，你一个个求要快</p>
<h4 id="蒙哥马利取模"><a href="#蒙哥马利取模" class="headerlink" title="蒙哥马利取模"></a>蒙哥马利取模</h4><p>Min_25 的博客有过介绍</p>
<p>核心步骤Reduce: （ $x \in [0,rn)$ 返回 $xn^{-1} \bmod r$）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span>(<span class="params">x</span>):</span></span><br><span class="line">    m=((x%n)*(inv(r)))%n</span><br><span class="line">    x=(x-m*r)//n</span><br><span class="line">    <span class="keyword">if</span> x&gt;=r:</span><br><span class="line">        <span class="keyword">return</span> x-r</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>究其本质大概是在 $n,r$ 互质的情况下映射 $f(a)=an$ 是 $\mathbb{F}_r$ 的自同态？</p>
<p>大量乘法取模的时候实际效率很高</p>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>太菜了写不动这个东西，给一份 zball 大佬的实现，效率极高</p>
<p><a href="https://www.luogu.com.cn/paste/eha6wtkl">Here</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0.20788920s consumed</span><br><span class="line">200000000000000003 300000000000000011</span><br></pre></td></tr></table></figure>

<p>比 <code>factor</code> 快上百倍、</p>
<p>同时 wikipedia 上也列举了许多 ecm 的高效实现，可以在 <a href="https://en.wikipedia.org/wiki/Lenstra_elliptic-curve_factorization#External_links">Wikipedia</a>中查看（需独特的上网技巧）</p>
<p><strong>Asusetic eru quionours</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>记一道数学题</title>
    <url>/2021/04/28/%E8%AE%B0%E4%B8%80%E9%81%93%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
    <content><![CDATA[<p>来自FJOI D2T3</p>
<span id="more"></span>

<h3 id="记一道数学题"><a href="#记一道数学题" class="headerlink" title="记一道数学题"></a>记一道数学题</h3><p>$\mathrm{D} $为微分算子，即$\mathrm{D}=\dfrac{\mathrm{d}}{\mathrm{d}x}$</p>
<p>Update : 更新更简洁的生成函数做法</p>
<p>为了式子的简洁忽略掉了一些 corner case </p>
<p>省略的求和指标一般是对 $i$ 求和</p>
<p><del>（颓了节美术课就搞出来了，考的时候在干嘛淦）</del></p>
<h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><p>设 $a_n=\dfrac{na_{n-1}+n(n-1)a_{n-2}}{2}+(-1)^n(1-\dfrac{n}{2})$</p>
<p>求 $\sum\binom{n}{i}(n-i+1)a_i$</p>
<h3 id="OI版"><a href="#OI版" class="headerlink" title="OI版"></a>OI版</h3><p>看到类似 $n^{\underline{i-1}}a_{n-i}$ 的可以考虑除个 $n!$ 搞 EGF</p>
<p>设 $b_n=\dfrac{a_n}{n!}$</p>
<p>则 $2b_n=b_{n-1}+b_{n-2}+\dfrac{2\times(-1)^n}{n!}-\dfrac{n(-1)^n}{n!}$</p>
<p>设 $b_n$ 的生成函数是 $B(x)$</p>
<p>$n(-1)^n$ 的 EGF 就是 $x\mathrm{D} e^{-x}=-xe^{-x}$</p>
<p>则 $2B(x)=xB(x)+x^2B(x)+2e^{-x}+xe^{-x}$</p>
<p>解出来 $B(x)=\dfrac{(x+2)e^{-x}}{2-x-x^2}=\dfrac{e^{-x}}{1-x}$</p>
<p>设 $s_n=\sum\binom{n}{i}(n-i+1)a_i=\sum\binom{n}{i}(n-i)a_i+\sum\binom{n}{i}a_i$</p>
<p>考虑前一项是 ${i}$ 与 ${a_i}$ 的二项卷积，即 $x\mathrm{D} e^{x}\dfrac{e^{-x}}{1-x}=\dfrac{x}{1-x}$</p>
<p>后一项是 ${1}$ 与 ${a_i}$ 的二项卷积，即$e^x\dfrac{e^{-x}}{1-x}=\dfrac{1}{1-x}$</p>
<p>则 $s_n$ 的 EGF 为 $\dfrac{1+x}{1-x}$</p>
<p>$s_n=n![x^n]\dfrac{1+x}{1-x}=n![x^n][(1+x)(1+x+x^2)+\dots]=2n!$</p>
<h3 id="MO版"><a href="#MO版" class="headerlink" title="MO版"></a>MO版</h3><p>看到这个 $na_{n-1} \quad n(n-1)a_{n-2}$ 就先除个 $n!$ ，设 $b_n=\dfrac{a_n}{n!}$</p>
<p>$2b_n=b_{n-1}+b_{n-2}+\dfrac{2\times(-1)^n}{n!}+\dfrac{(-1)^{n-1}}{(n-1)!}$</p>
<p>$2b_{n-1}=b_{n-2}+b_{n-3}+\dfrac{2\times(-1)^{n-1}}{(n-1)!}+\dfrac{(-1)^{n-2}}{(n-2)!}$</p>
<p>加起来</p>
<p>$2b_n+b_{n-1}=2b_{n-2}+b_{n-3}+\dfrac{2\times(-1)^n}{n!}+\dfrac{(-1)^{n-1}}{(n-1)!}+\dfrac{2\times(-1)^{n-1}}{(n-1)!}+\dfrac{(-1)^{n-2}}{(n-2)!}$</p>
<p>继续拆开</p>
<p>$2b_n+b_{n-1}=\dfrac{3\times(-1)^n}{n!}+\dfrac{3\times(-1)^{n-1}}{(n-1)!}+\dfrac{3\times(-1)^{n-2}}{(n-2)!}+\dots+\dfrac{2\times(-1)^{2}}{2!}+\dfrac{(-1)^1}{1!}+2b_2+b_1$</p>
<p>设 $c_n=b_n-\sum\limits_i\dfrac{(-1)^i}{i!}$</p>
<p>对比上面的式子能发现 $2c_n+c_{n-1}=0$ 且 $c_1=0$</p>
<p>所以所有 $c_n=0$ 即 $b_n=\sum\limits_i\dfrac{(-1)^i}{i!}$</p>
<p>$\binom{n}{i}a_i=n^{\underline{i}}b_i=n^{\underline{i}}\sum\limits_j\dfrac{(-1)^j}{j!}$</p>
<p>原式为 $\sum(n-i+1)n^{\underline{i}}\sum\limits_j \dfrac{(-1)^j}{j!}=\sum (n^{\underline{i+1}}+n^{\underline{i}})\sum\limits_j \dfrac{(-1)^j}{j!}$</p>
<p>考虑 $n^{\underline{i}}=\mathrm{D}^i x^n\big|_{x=1}$</p>
<p>则 $\sum (n^{\underline{i+1}}+n^{\underline{i}})\sum\limits_j \dfrac{(-1)^j}{j!}=(\sum(1+\mathrm{D})\mathrm{D}^i\sum\limits_j\dfrac{(-1)^j}{j!}x^n)\Big|_{x=1}$</p>
<p>$=((1+\mathrm{D})\sum\mathrm{D}^i\sum\limits_{j}\dfrac{(-1)^j}{j!})x^n\Big|_{x=1}$</p>
<p>交换求和 省略 $\big|_{x=1}$</p>
<p>$(1+\mathrm{D})\sum\limits_{j} \dfrac{(-1)^j}{j!}\sum\limits_{i \ge j} \mathrm{D}^ix^n=(1+\mathrm{D})\sum\limits_j \dfrac{(-1)^j}{j!}\dfrac{\mathrm{D}^j}{1-\mathrm{D}}x^n$ （没错就是可以把微分算子当作一个字母处理）</p>
<p>干掉求和号</p>
<p>$\dfrac{1+\mathrm{D}}{1-\mathrm{D}}e^{-\mathrm{D}} x^n$</p>
<p>$\dfrac{1+\mathrm{D}}{1-\mathrm{D}}(x-1)^n=\dfrac{1+\mathrm{D}}{1-\mathrm{D}}x^n\big|_{x=0}=2n!$ （就是对 $\mathrm{D}$ 展开了幂级数）</p>
<p>所以原式 $=2n!$</p>
<p><strong>Asusetic eru quionours</strong></p>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>烷基计数</title>
    <url>/2021/04/28/%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>Polya的奇怪应用</p>
<span id="more"></span>

<h3 id="烷基计数"><a href="#烷基计数" class="headerlink" title="烷基计数"></a>烷基计数</h3><p>参考：<a href="https://tieba.baidu.com/p/4929845825?red_tag=2138002071">神仙的化学计数</a></p>
<p>给出一个比较通用的计数方法</p>
<p>定义$Z(G)$为有限置换群$G$的循环指数，$Z(G)=\frac{1}{|G|}\sum\limits_{g\in G}\prod\limits_rs_r^{c_r(g)}$，这是一个关于$s_i$的多项式</p>
<p>$c_r(g)$是$g$的循环分解中有$r$个元素的循环，也就是将$g$循环分解表示加起来</p>
<p>比如$Z(S_3)=\frac{1}{6}(2s_3+3s_2s_1+s_1^3)$ (如果考虑手性就是群$\mathfrak{A}_3$)</p>
<p>而如果我们把$s_i$用多项式$\mathbb{Z}[x^r]$代替就是$Z(S_3,F(x))=\frac{1}{6}(2F(x^3)+3F(x^2)F(x)+F^3(x))$  (不懂为啥能这么搞，也找不到相关资料</p>
<p>考虑烷基计数</p>
<p>拆去第一个碳原子，剩下的取代基可以自由分配，所以其生成函数$F(x)=1+xZ(s_3,F(X))=1+\frac{x}{6}[2F(x^3)+3F(x^2)F(x)+F^3(x)]$</p>
<p>可以分治NTT或者牛顿迭代</p>
<p>选择不用脑子的牛顿迭代</p>
<p>$G(F(X))=1+\frac{x}{6}[2F(x^3)+3F(x^2)F(x)+F^3(x)]-F(x)$</p>
<p>设已经求出$H(x)$满足$G(H(x))\equiv0\pmod{ x^{\frac{n}{2}}}$</p>
<p>那么$F(x)=H(x)-\frac{G(H(x))}{G’(H(x))}$</p>
<p>$G’(H(x))$中因为已知可以当作常数$G’(H(x))=x\frac{3H(x)^2+3H(x^2)}{6}-1$</p>
<p>带入$F(X)=H(x)-\frac{6-x(H(x)^3+3H(x^2)H(x)+2H(x^3))-6H(x)}{3x(H(x)^2+H(x^2))-6}$</p>
<p>实际上这个方法像<a href="https://www.luogu.com.cn/problem/P6597">烯烃</a>/<a href="https://www.luogu.com.cn/problem/P6598">烷烃</a>计数都通用的，但是我懒得再写了</p>
<p>Tips:烷烃的话答案是</p>
<p>$G(x)=x[\frac{1}{24}F^4(x)+\frac 14 F^2(x)F(x^2)+\frac{1}{8}F^2(x^2)+\frac{1}{3}F(x)F(x^3)+\frac 14 F(x^4)]-\frac 12 F^2(x)+\frac 12 F(x^2)+F(x)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;dbg&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Poly &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> ll G = <span class="number">3</span>, invG = <span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; poly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e6</span> + <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(poly &amp;a, <span class="keyword">int</span> len, <span class="keyword">int</span> typ)</span> </span>&#123;</span><br><span class="line">    a.<span class="built_in">resize</span>(len);</span><br><span class="line">    <span class="keyword">int</span> lim = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid *= <span class="number">2</span>) &#123;</span><br><span class="line">        ll wn = <span class="built_in">qpow</span>(typ == <span class="number">1</span> ? G : invG, (mod - <span class="number">1</span>) / (mid * <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j += mid * <span class="number">2</span>) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; k++) &#123;</span><br><span class="line">                ll x = a[j + k], y = w * a[j + k + mid] % mod;</span><br><span class="line">                a[j + k]       = (x + y) % mod;</span><br><span class="line">                a[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">                w              = w * wn % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (typ == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> invdeg = <span class="built_in">qpow</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">        a[i] = a[i] * invdeg % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll W[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        W[i]  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="built_in">qpow</span>(<span class="number">3</span>, (mod - <span class="number">1</span>) / (i * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            W[i + j] = (ll)W[i + j - <span class="number">1</span>] * w % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(<span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt; deg) &#123;</span><br><span class="line">        len *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRev</span><span class="params">(<span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deg; i++) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) ? (deg &gt;&gt; <span class="number">1</span>) : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrepareNTT</span><span class="params">(<span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="built_in">getLen</span>(deg);</span><br><span class="line">    <span class="built_in">getRev</span>(L);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line">poly _mul(<span class="keyword">const</span> poly &amp;a, <span class="keyword">const</span> poly &amp;b) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res[i] = a[i] * b[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">poly <span class="keyword">operator</span>-(<span class="keyword">const</span> poly &amp;a) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res[i] = (mod - a[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">poly <span class="keyword">operator</span>+(<span class="keyword">const</span> poly &amp;a, <span class="keyword">const</span> poly &amp;b) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        res[i] = a[i] + b[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">poly <span class="keyword">operator</span>-(<span class="keyword">const</span> poly &amp;a, <span class="keyword">const</span> poly &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + -b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">inv</span><span class="params">(poly a)</span> </span>&#123;</span><br><span class="line">    poly res, inv_a;</span><br><span class="line">    res.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">    res[<span class="number">0</span>]  = <span class="built_in">qpow</span>(a[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="built_in">getLen</span>(a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= lim; len *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">PrepareNTT</span>(len + len);</span><br><span class="line">        inv_a = a;</span><br><span class="line">        inv_a.<span class="built_in">resize</span>(n);</span><br><span class="line">        res.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; n; i++) &#123;</span><br><span class="line">            inv_a[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NTT</span>(inv_a, n, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(res, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = <span class="number">1ll</span> * (<span class="number">2ll</span> - <span class="number">1ll</span> * inv_a[i] * res[i] % mod + mod) % mod *</span><br><span class="line">                     res[i] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NTT</span>(res, n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">resize</span>(a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Poly</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Poly;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    poly c(1, 1), hx2, hx3, p, q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len *= <span class="number">2</span>) &#123;</span><br><span class="line">        hx2 = hx3 = <span class="built_in">poly</span>(len * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            hx2[j &lt;&lt; <span class="number">1</span>] = c[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j * <span class="number">3</span> &lt; <span class="number">2</span> * len; j++)</span><br><span class="line">            hx3[j * <span class="number">3</span>] = c[j];</span><br><span class="line">        <span class="built_in">PrepareNTT</span>(len * <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(c, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(hx2, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(hx3, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        p = q = <span class="built_in">poly</span>(len * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (len * <span class="number">4</span>); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = j &lt; (len * <span class="number">2</span>) ? W[len * <span class="number">2</span> | j] : mod - W[len * <span class="number">2</span> | j];</span><br><span class="line">            q[j] =</span><br><span class="line">                (<span class="number">3ll</span> * w * ((<span class="built_in">ll</span>(c[j]) * c[j] % mod + hx2[j]) % mod) + mod - <span class="number">6</span>) %</span><br><span class="line">                mod;</span><br><span class="line">            p[j] = (w *</span><br><span class="line">                        ((<span class="built_in">ll</span>(c[j]) * c[j] % mod * c[j] +</span><br><span class="line">                          <span class="number">3ll</span> * hx2[j] * c[j] % mod + <span class="number">2ll</span> * hx3[j]) %</span><br><span class="line">                         mod) %</span><br><span class="line">                        mod +</span><br><span class="line">                    (mod - <span class="number">6ll</span>) * c[j] % mod + <span class="number">6ll</span>) %</span><br><span class="line">                   mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NTT</span>(p, len * <span class="number">4</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(q, len * <span class="number">4</span>, <span class="number">-1</span>);</span><br><span class="line">        q.<span class="built_in">resize</span>(len * <span class="number">2</span>);</span><br><span class="line">        q = <span class="built_in">inv</span>(q);</span><br><span class="line">        p.<span class="built_in">resize</span>(len * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(p, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NTT</span>(q, len * <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (len * <span class="number">4</span>); j++) &#123;</span><br><span class="line">            c[j] = (c[j] + (mod - p[j]) * (ll)q[j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NTT</span>(c, len * <span class="number">4</span>, <span class="number">-1</span>);</span><br><span class="line">        c.<span class="built_in">resize</span>(len * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">poly res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prework</span>(<span class="number">2e6</span> + <span class="number">10</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Polya</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵玩小凹</title>
    <url>/2021/04/28/%E7%9F%A9%E9%98%B5%E7%8E%A9%E5%B0%8F%E5%87%B9/</url>
    <content><![CDATA[<h4 id="【集训队作业2018】矩阵玩小凹"><a href="#【集训队作业2018】矩阵玩小凹" class="headerlink" title="【集训队作业2018】矩阵玩小凹"></a>【集训队作业2018】矩阵玩小凹</h4><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>一个$n\times m$的矩阵$A_{n,m}$，其中的元素是$[0,1]$中的随机实数，设$s_i=\sum A_{i,j}$求$Ex(\lfloor\min s_i\rfloor^k)$</p>
<span id="more"></span>

<p>(因为没发现能交的地方，random了几组数据放在了<a href="https://www.luogu.com.cn/problem/U155544">矩阵玩小凹</a>上（并不保证写对了）)</p>
<h4 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h4><p>因为每一行本质相同，所以我们只考虑第一行</p>
<p>记$f_i$为$\lfloor s_1 \rfloor=i$的概率，$d_i$是$\lfloor\min(s_i)\rfloor=i$的概率，那么答案就是$\sum\limits_{i=1}^{m-1}i^kd_i$</p>
<p>同时$d_i=(\sum\limits_{j=i}^{n} f_j)^n-(\sum\limits_{j=i+1}^{n}f_j)^n$</p>
<p>这都是好算的，我们考虑$f_i$怎么算</p>
<p>记$g_i=\sum_{j=1}^{i}A_{1,j}-\lfloor\sum_{j=1}^{i}A_{1,j}\rfloor$，容易发现这也是$[0,1]$内随机生成的</p>
<p>那么$\lfloor s_1\rfloor=\sum\limits_{i=2}^m[g_i&lt;g_{i-1}]$</p>
<p>因为如果当前的$g_i$小于上一个$g_{i-1}$说明一定“溢出”了一个整数位（因为$A_{i,j}\in[0,1]$）</p>
<p>也就是说$f_i$就是随机$[0,1]$排列种上升的位置有$i$个的概率（这里我们忽略了存在相同的数字，因为在实数里随机出两个同样的数字的概率基本无）</p>
<p>那这个东西，我们把随机排列$n$中有$i$个上升位置的方案数</p>
<p>就是欧拉数$\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle$</p>
<p>实际上我们有$\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle=\sum(-1)^{i}\binom{n+1}{i}(m-i+1)^n$</p>
<p>证明有亿点难</p>
<p>对于$x_1+x_2+\dots+x_n \le x \quad x_i \ge 0$的超立方体体积记作$V_n(x)$</p>
<p>容易发现$h_1(x)=x$</p>
<p>$V_i(x)=\int_0^nh_{i-1}(t)\rm{d}t$</p>
<p>并不需要技巧就能得出$V_i(n)=\frac{n^i}{i!}$</p>
<p>考虑最原始的含义，$\sum\limits_{i=0}^m\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle$就是$\lfloor s_1\rfloor\le i+1$的概率，容斥$x&gt; 1$的个数（因为$A_{i,j}\in[0,1]$），那么</p>
<p>$\sum\limits_{i=0}^m\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle=\sum\limits_{i=0}^{m+1}(-1)^i\binom{n}{i}V_n(m-i+1)$</p>
<p>差分一下就能得到$\left\langle\begin{matrix}n \ i\end{matrix}\right\rangle=\sum(-1)^{i}\binom{n+1}{i}(m-i+1)^n$</p>
<p>这个是$i^n$与$(-1)^i\binom{n+1}{i}$的卷积，NTT $O(n\log n)$解决</p>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.04.19模拟赛</title>
    <url>/2021/04/28/2021-04-19%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>很久之前的东西</p>
<span id="more"></span>

<h2 id="2021-04-19-模拟赛"><a href="#2021-04-19-模拟赛" class="headerlink" title="2021.04.19 模拟赛"></a>2021.04.19 模拟赛</h2><h3 id="T1-青蛙"><a href="#T1-青蛙" class="headerlink" title="T1 青蛙"></a>T1 青蛙</h3><p><a href="https://sjzezoj.com/problem/344">题面</a></p>
<p>求第 $k$ 大这个操作可以类似滑动窗口一个个扫过去</p>
<p>求完之后就是置换的 $m$ 次幂，$m$ 不太大所以完全可以倍增水过去（需要滚动数组一下） $O(n\log n)$</p>
<p>如果很大可以考虑找环，找到之后减去柄长模环，复杂度 $O(n)$</p>
<p>倍增写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">ll m;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> pos[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        ans[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll l = <span class="number">1</span>, r = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; a[r + <span class="number">1</span>] - a[i] &lt; a[i] - a[l]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        pos[i][<span class="number">0</span>] = (a[r] - a[i] &gt; a[i] - a[l] ? r : l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; (<span class="number">1ll</span> &lt;&lt; i) &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = (i &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (m &amp; (<span class="number">1ll</span> &lt;&lt; i)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                ans[j] = pos[ans[j]][now];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            pos[j][now ^ <span class="number">1</span>] = pos[pos[j][now]][now];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>

<h3 id="T2-环"><a href="#T2-环" class="headerlink" title="T2 环"></a>T2 环</h3><p><a href="https://sjzezoj.com/problem/345">题面</a></p>
<p>看起来就很差分约束，如果固定了长度判断有解就按照限制连边，正整数的限制意味着 $i \rightarrow i+1$ 至少是 $1$ ，还需要按是否跨过零点分类讨论一下</p>
<p>二分一个答案区间不太现实，考虑二分上下界，那我们需要知道某个条件下需要向大还是向小调整</p>
<p>如果无解肯定是负环，我们希望知道负环上每个边的与总长度的关系</p>
<p>即当总长度变大/小时它怎么变，变大变小分别记作 $1,-1$，无关为 $0$，如果这些和是正的说明需要调大总长度才能无负环，反之同理</p>
<p>这样就能二分出上下界</p>
<p>复杂度 $O(n^2\log w)$</p>
<p>还没码</p>
<h3 id="T3-小基的高智商测试"><a href="#T3-小基的高智商测试" class="headerlink" title="T3 小基的高智商测试"></a>T3 小基的高智商测试</h3><p><a href="https://sjzezoj.com/problem/346">题面</a></p>
<p>阅读理解题</p>
<p>先把相等的点用并查集放一起，然后按小于连边</p>
<p>先排除掉环一类的无解情况，剩下的就是一个森林</p>
<p>连上一个虚点就能得到一个树，一开始以为是拓扑序计数，发现这个同一层的点是可以相等的</p>
<p>考虑直接钦定排名，相等的拿到同一个排名</p>
<p> 令 $f_i$ 表示用 $1\sim i$ 的数字分配排名的方案数，那么树上DP</p>
<p>设 $dp_{x,i}$ 为 $x$ 的子树用 $1 \sim i$ 的分配方案，于是 $dp_{x,i}=dp_{x,i-1}+\prod\limits_{v\in son(x)}dp_{v,j-1}$</p>
<p>即分配 $1\sim j-1$ 的方案和钦定自己分配 $j$ 的方案</p>
<p>但是发现这么定义的问题是可能有的排名没分配出去，二项式反演一下解决</p>
<p>即 $f_i=\sum\binom{i}{j}g_j \Rightarrow g_i=\sum(-1)^j\binom{i}{j}f_{i-j}$</p>
<p>复杂度 $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">    VOID = <span class="number">-1</span>,</span><br><span class="line">    Equal,</span><br><span class="line">    Less,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Oper</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    Type typ;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">&#125; edge[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++ecnt].v = v;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u]        = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x     = <span class="built_in">find</span>(x);</span><br><span class="line">    y     = <span class="built_in">find</span>(y);</span><br><span class="line">    fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    ifac[n + <span class="number">1</span>] = <span class="built_in">qpow</span>(fac[n + <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ifac[i] = <span class="number">1ll</span> * ifac[i + <span class="number">1</span>] * (<span class="number">1ll</span> * i + <span class="number">1ll</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">bool</span> G[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], flag = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[x][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = edge[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[x][j] = <span class="number">1ll</span> * dp[x][j] * dp[v][j - <span class="number">1</span>] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[x][i] = (<span class="number">1ll</span> * dp[x][i] + <span class="number">1ll</span> * dp[x][i - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[x][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">char</span> rub[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; q[i].u &gt;&gt; rub &gt;&gt; q[i].v;</span><br><span class="line">        <span class="keyword">if</span> (rub[<span class="number">0</span>] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            q[i].typ = Equal;</span><br><span class="line">            <span class="built_in">merge</span>(q[i].u, q[i].v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].typ = Less;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].typ == Equal) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(q[i].u), y = <span class="built_in">find</span>(q[i].v);</span><br><span class="line">        <span class="keyword">if</span> (!G[x][y]) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y);</span><br><span class="line">            G[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> QAQ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i &amp;&amp; in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>, i);</span><br><span class="line">            QAQ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[<span class="built_in">find</span>(i)]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ans = (ans + mod - (<span class="number">1ll</span> * <span class="built_in">C</span>(i, j) % mod * dp[<span class="number">0</span>][i - j]) % mod) %</span><br><span class="line">                      mod;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = (ans + <span class="number">1ll</span> * <span class="built_in">C</span>(i, j) % mod * dp[<span class="number">0</span>][i - j] % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Asusetic eru quionours</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>差分约束</tag>
        <tag>DP</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.04.20模拟赛</title>
    <url>/2021/04/28/2021-04-20%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>很久之前的东西</p>
<span id="more"></span>

<h2 id="2021-04-20-模拟赛"><a href="#2021-04-20-模拟赛" class="headerlink" title="2021.04.20 模拟赛"></a>2021.04.20 模拟赛</h2><p>越来越菜</p>
<h3 id="T1-越野赛车问题"><a href="#T1-越野赛车问题" class="headerlink" title="T1 越野赛车问题"></a>T1 越野赛车问题</h3><p><a href="https://sjzezoj.com/problem/347">题面</a></p>
<p><del>矩阵乘写挂也有五十()</del></p>
<p>虽然有线段树分治+并查集的解法，不过个人感觉DDP比较好想</p>
<p>其实题目就是说一个树每个边在 $l_i$ 出现 $r_i$ 消失，时刻 $v$ 的直径</p>
<p>DDP的话</p>
<p>设 $dp_{x,1}$ 表示 $x$ 的子树内直径长度，$dp_{x,0}$ 表示起点为 $x$ 的最长链</p>
<p>$dp_{x,1}=\max{\max\limits_{y\in son(x)}dp_{y,1},\max\limits_{y,z \in son(x)}dp_{y,0}+dp_{z,0}}$</p>
<p>$dp_{x,0}=\max\limits_{y\in son(x)}{dp_{y,0}}+1$</p>
<p>DDP套路，设</p>
<p>$g_{x,0}=\max\limits_{y\in light(x)}dp_{y,0}$<br>$g_{x,1}=\max{\max\limits_{y\in light(x)}dp_{y,1},\max\limits_{y,z\in light(x)}dp_{y,0}+dp_{z,0}}$</p>
<p>于是</p>
<p>$dp_{x,0}=\max{g_{x,0}+dp_{son,0}}+1$<br>$dp_{x,1}=\max{dp_{son,1},g_{x,1},dp_{son,0}+g_{x,0}}$</p>
<p>转移为<br>$$<br>\begin{bmatrix}\begin{array}{c}1 &amp; -\infty &amp; g_{x,0}+1\g_{x,0} &amp; 0 &amp;g_{x,1}\-\infty &amp; -\infty &amp; 0\end{array}\end{bmatrix}\begin{bmatrix}\begin{array}{c}dp_{son,0}\dp_{son,1}\0\end{array}\end{bmatrix}=\begin{bmatrix}\begin{array}{c}dp_{x,0}\dp_{x,1}\0\end{array}\end{bmatrix}<br>$$<br>对于 $g_{x,0/1}$ 的维护需要开两个可删堆</p>
<p>一个记录 $dp_{x,0}$ 一个 $dp_{x,1}$，都只维护轻儿子</p>
<p>$g_{x,0}$ 是第一个里最大的</p>
<p>$g_{x,1}$ 是第二个最大的或者第一个前两个数</p>
<p>复杂度$O(n\log^2n)$ LCT可优化为 $O(n\log n)$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N &#x3D; 70005;</span><br><span class="line">int n, m;</span><br><span class="line">int x[N], y[N];</span><br><span class="line">struct DelHeap &#123;</span><br><span class="line">    priority_queue&lt;int&gt; q, p;</span><br><span class="line">    void clear() &#123;</span><br><span class="line">        while (!q.empty() &amp;&amp; !p.empty() &amp;&amp; q.top() &#x3D;&#x3D; p.top())</span><br><span class="line">            q.pop(), p.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">    void del(int x) &#123;</span><br><span class="line">        p.push(x), clear();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        clear();</span><br><span class="line">        return q.top();</span><br><span class="line">    &#125;</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        clear();</span><br><span class="line">        return q.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int v, l, r;</span><br><span class="line">    int nxt;</span><br><span class="line">&#125; edge[N * 2];</span><br><span class="line">int head[N], ecnt;</span><br><span class="line">void add(int u, int v, int l, int r) &#123;</span><br><span class="line">    edge[++ecnt].v &#x3D; v;</span><br><span class="line">    edge[ecnt].l   &#x3D; l;</span><br><span class="line">    edge[ecnt].r   &#x3D; r;</span><br><span class="line">    edge[ecnt].nxt &#x3D; head[u];</span><br><span class="line">    head[u]        &#x3D; ecnt;</span><br><span class="line">&#125;</span><br><span class="line">namespace DDP &#123;</span><br><span class="line">DelHeap q1[N], q2[N];</span><br><span class="line">int leaf[N];</span><br><span class="line">int g0(int x) &#123;</span><br><span class="line">    if (q1[x].empty()) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return q1[x].top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int g1(int x) &#123;</span><br><span class="line">    int ans &#x3D; q2[x].empty() ? 0 : q2[x].top();</span><br><span class="line">    int sum &#x3D; 0, tmp;</span><br><span class="line">    if (q1[x].empty()) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    sum &#x3D; q1[x].top();</span><br><span class="line">    q1[x].pop();</span><br><span class="line">    tmp &#x3D; sum;</span><br><span class="line">    if (!q1[x].empty()) &#123;</span><br><span class="line">        sum +&#x3D; q1[x].top();</span><br><span class="line">    &#125;</span><br><span class="line">    q1[x].push(tmp);</span><br><span class="line">    return max(sum, ans);</span><br><span class="line">&#125;</span><br><span class="line">int top[N], fa[N], dep[N], son[N], siz[N], id[N], pos[N], tim;</span><br><span class="line">void dfs1(int x, int f) &#123;</span><br><span class="line">    dep[x] &#x3D; dep[f] + 1;</span><br><span class="line">    fa[x]  &#x3D; f;</span><br><span class="line">    siz[x] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; head[x]; i; i &#x3D; edge[i].nxt) &#123;</span><br><span class="line">        int v &#x3D; edge[i].v;</span><br><span class="line">        if (v &#x3D;&#x3D; f) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(v, x);</span><br><span class="line">        siz[x] +&#x3D; siz[v];</span><br><span class="line">        if (siz[v] &gt; siz[son[x]]) &#123;</span><br><span class="line">            son[x] &#x3D; v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int x, int topf) &#123;</span><br><span class="line">    top[x]   &#x3D; topf;</span><br><span class="line">    id[x]    &#x3D; ++tim;</span><br><span class="line">    pos[tim] &#x3D; x;</span><br><span class="line">    if (!son[x]) &#123;</span><br><span class="line">        leaf[x] &#x3D; x;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(son[x], topf);</span><br><span class="line">    leaf[x] &#x3D; leaf[son[x]];</span><br><span class="line">    for (int i &#x3D; head[x]; i; i &#x3D; edge[i].nxt) &#123;</span><br><span class="line">        int v &#x3D; edge[i].v;</span><br><span class="line">        if (v &#x3D;&#x3D; fa[x] || v &#x3D;&#x3D; son[x]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Matrix &#123;</span><br><span class="line">    int a[3][3];</span><br><span class="line">    Matrix() &#123;</span><br><span class="line">        memset(a, 0, sizeof(a));</span><br><span class="line">    &#125;</span><br><span class="line">    int *operator[](int x) &#123;</span><br><span class="line">        return a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator*(Matrix b) &#123;</span><br><span class="line">        Matrix res &#x3D; Matrix();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                res[i][j] &#x3D; -(1 &lt;&lt; 31);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">                    res[i][j] &#x3D; max(res[i][j], a[i][k] + b[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int w[N];</span><br><span class="line">namespace SegmentTree &#123;</span><br><span class="line">const int INF &#x3D; (1 &lt;&lt; 30);</span><br><span class="line">Matrix tr[N * 4];</span><br><span class="line">void init(int rt, int x) &#123;</span><br><span class="line">    tr[rt].a[1][0] &#x3D; g0(x);</span><br><span class="line">    tr[rt].a[1][1] &#x3D; 0;</span><br><span class="line">    tr[rt].a[1][2] &#x3D; g1(x);</span><br><span class="line">    tr[rt].a[2][0] &#x3D; -INF;</span><br><span class="line">    tr[rt].a[2][1] &#x3D; -INF;</span><br><span class="line">    tr[rt].a[2][2] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">void build(int rt, int l, int r) &#123;</span><br><span class="line">    if (l &#x3D;&#x3D; r) &#123;</span><br><span class="line">        tr[rt][0][0] &#x3D; -INF;</span><br><span class="line">        tr[rt][0][1] &#x3D; -INF;</span><br><span class="line">        tr[rt][0][2] &#x3D; 0;</span><br><span class="line">        init(rt, pos[l]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid &#x3D; (l + r) &#x2F; 2;</span><br><span class="line">    build(rt * 2, l, mid);</span><br><span class="line">    build(rt * 2 + 1, mid + 1, r);</span><br><span class="line">    tr[rt] &#x3D; tr[rt * 2] * tr[rt * 2 + 1];</span><br><span class="line">&#125;</span><br><span class="line">Matrix query(int rt, int l, int r, int L, int R) &#123;</span><br><span class="line">    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;</span><br><span class="line">        return tr[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    int mid &#x3D; (l + r) &#x2F; 2;</span><br><span class="line">    if (R &lt;&#x3D; mid) &#123;</span><br><span class="line">        return query(rt * 2, l, mid, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    if (L &gt; mid) &#123;</span><br><span class="line">        return query(rt * 2 + 1, mid + 1, r, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    return query(rt * 2, l, mid, L, R) * query(rt * 2 + 1, mid + 1, r, L, R);</span><br><span class="line">&#125;</span><br><span class="line">void update(int rt, int l, int r, int x) &#123;</span><br><span class="line">    if (l &#x3D;&#x3D; r) &#123;</span><br><span class="line">        if (w[pos[l]]) &#123;</span><br><span class="line">            tr[rt][0][0] &#x3D; 1;</span><br><span class="line">            tr[rt][0][1] &#x3D; -INF;</span><br><span class="line">            tr[rt][0][2] &#x3D; g0(pos[l]) + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tr[rt][0][0] &#x3D; -INF;</span><br><span class="line">            tr[rt][0][1] &#x3D; -INF;</span><br><span class="line">            tr[rt][0][2] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        init(rt, pos[l]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid &#x3D; (l + r) &#x2F; 2;</span><br><span class="line">    if (x &lt;&#x3D; mid) &#123;</span><br><span class="line">        update(rt * 2, l, mid, x);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        update(rt * 2 + 1, mid + 1, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[rt] &#x3D; tr[rt * 2] * tr[rt * 2 + 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125; &#x2F;&#x2F; namespace SegmentTree</span><br><span class="line">Matrix query(int x) &#123;</span><br><span class="line">    return SegmentTree::query(1, 1, n, id[x], id[leaf[x]]) * Matrix();</span><br><span class="line">&#125;</span><br><span class="line">void update(int x, int k) &#123;</span><br><span class="line">    w[x] &#x3D; k;</span><br><span class="line">    while (top[x] !&#x3D; 1) &#123;</span><br><span class="line">        Matrix tmp1 &#x3D; query(top[x]);</span><br><span class="line">        SegmentTree::update(1, 1, n, id[x]);</span><br><span class="line">        Matrix tmp2 &#x3D; query(top[x]);</span><br><span class="line">        x           &#x3D; fa[top[x]];</span><br><span class="line">        q1[x].del(tmp1[0][0]);</span><br><span class="line">        q1[x].push(tmp2[0][0]);</span><br><span class="line">        q2[x].del(tmp1[1][0]);</span><br><span class="line">        q2[x].push(tmp2[1][0]);</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTree::update(1, 1, n, id[x]);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; p[N];</span><br><span class="line">int ans[N];</span><br><span class="line">void solve() &#123;</span><br><span class="line">    dfs1(1, 0);</span><br><span class="line">    dfs2(1, 1);</span><br><span class="line">    SegmentTree::build(1, 1, n);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        for (int j &#x3D; head[i]; j; j &#x3D; edge[j].nxt) &#123;</span><br><span class="line">            int v &#x3D; edge[j].v;</span><br><span class="line">            if (fa[i] &#x3D;&#x3D; v) &#123;</span><br><span class="line">                p[edge[j].l].push_back(i);</span><br><span class="line">                p[edge[j].r].push_back(-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        for (auto x : p[i]) &#123;</span><br><span class="line">            if (x &gt; 0) &#123;</span><br><span class="line">                update(x, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] &#x3D; query(1)[1][0];</span><br><span class="line">        for (auto x : p[i]) &#123;</span><br><span class="line">            if (x &lt; 0) &#123;</span><br><span class="line">                update(-x, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int x;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">        printf(&quot;%d\n&quot;, ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; &#x2F;&#x2F; namespace DDP</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">        int u, v, l, r;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;r);</span><br><span class="line">        add(u, v, l, r);</span><br><span class="line">        add(v, u, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    DDP::solve();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Asusetic eru quionours</span><br></pre></td></tr></table></figure>

<h3 id="T2-方舟系统"><a href="#T2-方舟系统" class="headerlink" title="T2 方舟系统"></a>T2 方舟系统</h3><p><a href="https://sjzezoj.com/problem/348">题面</a></p>
<p>考虑朴素 dp : $dp_i = \min\limits_{i&lt;j\le n+1}{dp_j+|a_i-(j-i-1)|}$</p>
<p>绝对值很难看，拆开</p>
<p>$dp_i\ =\min\limits_{i&lt; j\le n+1}\begin{cases}<br>dp_j-j+(a_i+i+1)&amp;a_i+i+1\ge j\<br>dp_j+j-(a_i+i+1)&amp;a_i+i+1&lt; j<br>\end{cases}$</p>
<p>分别用树状数组/线段树维护两个区间最小值</p>
<p>复杂度 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> c[N];</span><br><span class="line">    <span class="built_in">BIT</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt;= n) &#123;</span><br><span class="line">            c[pos] = <span class="built_in">min</span>(c[pos], v);</span><br><span class="line">            pos += <span class="built_in">lowbit</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, c[pos]);</span><br><span class="line">            pos -= <span class="built_in">lowbit</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; d1, d2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    d1.<span class="built_in">update</span>(n - a[<span class="number">1</span>], a[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    d2.<span class="built_in">update</span>(a[<span class="number">1</span>] + <span class="number">1</span>, -a[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minv1 = d1.<span class="built_in">query</span>(n - i + <span class="number">1</span>), minv2 = d2.<span class="built_in">query</span>(i);</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(minv1 - i, minv2 + i);</span><br><span class="line">        d1.<span class="built_in">update</span>(n - a[i] - i + <span class="number">1</span>, dp[i - <span class="number">1</span>] + a[i] + i);</span><br><span class="line">        d2.<span class="built_in">update</span>(a[i] + i, dp[i - <span class="number">1</span>] - a[i] - i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3-椅子"><a href="#T3-椅子" class="headerlink" title="T3 椅子"></a>T3 椅子</h3><p><a href="https://sjzezoj.com/problem/349">题面</a></p>
<p>[原题]([AT2645 <a href="https://www.luogu.com.cn/problem/AT2645">ARC076D] Exhausted? - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</p>
<p>大力贪心</p>
<p>如果仅有 $l_i$ 的限制显然很好做，贪心扫一遍</p>
<p>加上 $r_i$ 后需要反悔，替换的时候必然是把 $r_i$ 最小的扔出去，因为他能坐的位置更多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans, qp[N], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Data &amp;A, <span class="keyword">const</span> Data &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.l != B.l) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.l &lt; B.l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.r &gt; B.r;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>, t = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(a[i].r);</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= t &amp;&amp; h &lt;= a[i].l) &#123;</span><br><span class="line">            h++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            qp[++cnt] = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(qp + <span class="number">1</span>, qp + cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= t &amp;&amp; qp[i] &lt;= t) &#123;</span><br><span class="line">            t--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>动态DP</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
</search>
